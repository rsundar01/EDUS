package com.security.cryptoutility;

/*import java.security.SecureRandom;
import java.util.List;
import java.util.Properties;

import com.idps.IdpsClient;
import com.idps.domain.item.Key;
import com.idps.domain.item.NoSuchVersionException;
import com.idps.domain.item.Secret;

import org.apache.commons.codec.binary.Base64;*/


/**
 * Created by cloudera on 9/26/16.
 */
/*class IDPS implements KeyManagementServices {*/

    /* By default keys generated by an instance of this class will have following IDPS properties  */
    /* isEnumerable = true */
    /* isExportable = true */
    /* metadata = empty string */
    /* applicanceCacheTTL = 60 sec */
    /* isVersioned = true */

/*    private final KeyManagementPolicy.KeyManagementSystem keyManagementSystem =
                                            KeyManagementPolicy.KeyManagementSystem.INTUIT;

    private Properties connectionProperties;
    private IdpsClient idpsClient;
    private boolean isInitialized = false;
    private List<String> keyList;
    private SecureRandom secureRandom;
    private CryptoPolicy cryptoPolicy;

    public IDPS(Properties connectionProperties,
                    CryptoPolicy cryptoPolicy) throws EDUSException{

        this.connectionProperties = connectionProperties;

        this.cryptoPolicy = cryptoPolicy;

    }

    public void initialize() throws EDUSException{

        try {

            idpsClient = IdpsClient.Factory.newInstance(connectionProperties);

            secureRandom = IdpsClient.Random.getSecureRandom();

            isInitialized = true;

        } catch (Exception e){

            throw new EDUSException(e);
        }
    }

    private void checkAndInitialize() throws EDUSException{

        if( !isInitialized ){

            initialize();
        }
    }


    public KeyManagementPolicy getKeyManagementPolicy(){

        return null;
    }


    public byte[] getKeyBytes(String keyID) throws EDUSException {
        byte[] kekBytes = null;

        checkAndInitialize();

        try{

            Secret secret = idpsClient.getSecretLatest(keyID);
            Key secretKey = null;
            if(secret instanceof  Key){
                secretKey = (Key)secret;
            }

            kekBytes = secretKey.getValue();

        } catch(Exception e){

            throw new EDUSException(e);

        }

        return kekBytes;
    }

    public boolean generateKey(String keyID) throws EDUSException {

        boolean returnValue = false;

        checkAndInitialize();

        try{
            Key.KeyAlgorithm algorithm = translateEncryptionAlgorithm(cryptoPolicy);

            idpsClient.generateKey(keyID, algorithm, false);

            returnValue = true;

        } catch (EDUSException ede){
            throw ede;
        } catch (Exception e){
            throw new EDUSException(e);
        }

        return  returnValue;
    }


    public boolean updateKey(String keyID) throws EDUSException{

        boolean returnValue = false;

        try{
            Key.KeyAlgorithm algorithm = translateEncryptionAlgorithm(cryptoPolicy);

            idpsClient.updateKeyGenerate(keyID, algorithm, "");

            returnValue = true;

        } catch (EDUSException ede){
            throw ede;
        } catch (Exception e){
            throw new EDUSException(e);
        }

        return returnValue;
    }

    // Translate CryptoPolicy.Algorithm to Key.KeyAlgorithm
    private Key.KeyAlgorithm translateEncryptionAlgorithm(CryptoPolicy cryptoPolicy) throws EDUSException{


        CryptoPolicy.KeySize keySizes[] =  CryptoPolicy.KeySize.values();

        switch (cryptoPolicy.getAlgorithm()){

            case AES_CBC_NONE:
            case AES_CBC_HMACSHA1:
            case AES_CBC_HMACSHA256: {

                switch(cryptoPolicy.getEncryptKeySize()){

                    case 16:
                        return Key.KeyAlgorithm.AES128_CBC;

                    case 32:
                        return Key.KeyAlgorithm.AES256_CBC;

                    default:
                        throw new EDUSException("Invalid key size. Key size mismatch between cryptopolicy and keymanagment system");
                }

            }

            case AES_GCM_HMACSHA1:
            case AES_GCM_HMACSHA256:

                switch (cryptoPolicy.getEncryptKeySize()){

                    case 16:
                        return Key.KeyAlgorithm.AES128_GCM;

                    case 32:
                        return Key.KeyAlgorithm.AES256_GCM;

                    default:
                        throw new EDUSException("Invalid key size. Key size mismatch between cryptopolicy and keymanagment system");
                }

            default:
                throw new EDUSException("Cipher specified in the crypto policy is not available in the key management system");
        }

    }

    public String encrypt(String kekId, byte[] blob) throws EDUSException{

        return encrypt(kekId, null, blob);

    }

    public String encryptWithVersion(String keyId, byte[] blob, int version) throws EDUSException{

        KeyMetadata keyMetadata = new KeyMetadata(version);

        return encrypt(keyId, keyMetadata, blob);
    }

    public String encrypt(String kekId, KeyMetadata keyMetadata, byte[] blob) throws EDUSException{
        try {

            Key key = getKeyHandle(kekId, keyMetadata);

            byte[] encryptedKeyBytes = key.encrypt(blob);

            String encryptedString = Base64.encodeBase64String(encryptedKeyBytes);

            return encryptedString;

        }catch(Exception e){

            throw new EDUSException(e);

        }
    }

    public byte[] decrypt(String kekId, String encryptedKeyString) throws EDUSException{

        return decrypt(kekId, null, encryptedKeyString);

    }

    public byte[] decryptWithVersion(String keyId, String encryptedString, int version) throws EDUSException{

        KeyMetadata keyMetadata = new KeyMetadata(version);

        return decrypt(keyId, keyMetadata, encryptedString);

    }

    public byte[] decrypt(String kekId, KeyMetadata keyMetadata, String encryptedKeyString) throws EDUSException{

        try{
            Key key = getKeyHandle(kekId, keyMetadata);

            byte[] encryptedKeyBytes = Base64.decodeBase64(encryptedKeyString);

            byte[] keyblob = key.decrypt(encryptedKeyBytes);

            return keyblob;

        }catch (Exception e){
            throw new EDUSException(e);
        }
    }


    public String getRandomKeyIDFromList() throws EDUSException{

        String kekId = null;

        if( keyList == null ){
            return kekId;
        }

        byte[] randomValue = getRandomBytesImpl(1);

        int randomOffset = randomValue[0] & 0xFF;

        randomOffset = randomOffset % (keyList.size());

        kekId = keyList.get(randomOffset);

        return kekId;
    }

    public byte[] getSeed(int size) throws EDUSException{

        return secureRandom.generateSeed(size);
    }

    public byte[] getRandomBytes(int size) throws EDUSException{

        return getRandomBytesImpl(size);
    }

    private byte[] getRandomBytesImpl(int size) throws EDUSException{

        byte[] buffer = new byte[size];

        secureRandom.nextBytes(buffer);

        return buffer;
    }


    public KeyManagementPolicy.KeyManagementSystem getKeyManagementSystem() throws EDUSException{

        return keyManagementSystem;
    }

    public void loadKeyList(List<String> keyList) throws EDUSException{

        if( verifyKeyList(keyList) ){

            this.keyList = keyList;
        }

    }

    public void generateKeyList(List<String> keyList) throws EDUSException{

        this.keyList = keyList;

        generateKeyListPrivate();
    }

    public void updateKeyList() throws EDUSException{

        rekeyKeyListPrivate();

    }

    private Key getKeyHandle(String keyId, KeyMetadata keyMetadata) throws NoSuchVersionException{
        Key key = null;
        if (keyMetadata == null) {
            key = idpsClient.newKeyHandleLatest(keyId);
        } else {
            key = idpsClient.newKeyHandle(keyId, keyMetadata.getKeyVersion());
        }

        return key;
    }

    private boolean verifyKeyList(List<String> keyList) throws EDUSException{
        boolean returnVal = true;

        if( keyList == null ){

            throw new EDUSException(new NullPointerException("Key list is null"));
        }

        for(String kekId : keyList){

            try {
                idpsClient.newKeyHandleLatest(kekId).getValue();
            }catch (Exception e){
                throw new EDUSException(e);
            }

        }

        return returnVal;
    }

    private boolean rekeyKeyListPrivate() throws EDUSException{
        boolean returnVal = true;

        if( keyList == null ){

            throw new EDUSException(new NullPointerException("Key list is null"));
        }

        for(String keyId : keyList){

            try {
                //idpsClient.updateKeyGenerate(idpsClient.newKeyHandleLatest(keyId));
                idpsClient.updateKeyGenerate(keyId, translateEncryptionAlgorithm(cryptoPolicy), "");

            }catch(Exception e) {
                throw new EDUSException(e);
            }

        }

        return returnVal;
    }


    private boolean generateKeyListPrivate() throws EDUSException{

        boolean returnVal = true;

        if( keyList == null ){

            throw new EDUSException(new NullPointerException("Key list is null"));
        }

        for(String keyId : keyList){

            generateKey(keyId);
        }

        return returnVal;
    }
}
*/